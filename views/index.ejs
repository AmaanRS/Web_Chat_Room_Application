<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <script src="/socket.io/socket.io.js"></script>
    <style>
        #chat_area {
            background: #000;
            width: 83rem;
            height: 29rem;
            overflow-y: scroll;
            overflow-x: hidden;

        }

        #chat_area::-webkit-scrollbar {
            display: none;
        }

        .left {
            background-color: aqua;
            width: 100%;
            height: 10%;
            display: flex;
            flex-direction: row;
            margin-top: 10px;
            margin-bottom: 10px;

        }

        .right {
            background-color: aqua;
            width: 96%;
            height: 10%;
            display: flex;
            flex-direction: row-reverse;
            margin-top: 10px;
            margin-bottom: 10px;

        }

        .center {
            background-color: aqua;
            width: 100%;
            height: 10%;
            display: flex;
            justify-content: space-around;
            align-items: center;
            margin-top: 10px;
            margin-bottom: 10px;
        }

        .left_file{
            width: 100%;
            margin: 50px;
        }

        .right_file{
            width: 96%;
            display: flex;
            flex-direction: row-reverse;
            margin-bottom: 50px;
            margin-top: 50px;
            padding-right: 50px;
            
        }

        .img_file{
            object-fit: contain;
            width: 35%;
        }

        .any_file{
            color: white;
            border: 5px solid white;
            padding: 10px;
            margin: 10px;
        }
        #chat_options{
            display: flex;
            justify-content: space-between;
            align-items: center;
            height: 60px;
        }
    </style>
</head>

<body>
    <div>
        <%= room_id %>
            <div id="chat_area">
            </div>
            <div id="chat_options">
                <div>
                    <br>
                    Message
                    <input id="message">
                    <button type="submit" id="submit_btn">Send</button>
                    <br>
                </div>
                <div>
                    <br>
                    <br>
                    Send files
                    <input type="file" id="file_input">
                    <br>
                    <button id="send_pic">Send</button>
                    <br>
                    <br>
                </div>
                <div>
                    <br>
                    <br>
                    <br>
                    <br>
                    Record audio
                    <button id="start_record">Start recording</button>
                    <button id="stop_record">Stop recording</button>
                    <button id="send_record">Send Audio</button>
                </div>
            </div>
            
    </div>
</body>
<script>
    const socket = io();
    const message = document.getElementById("message")
    const username = '<%= username%>';
    const room_id = '<%= room_id%>';
    socket.emit("new_user", { "username": username, "room_id": room_id })
    socket.on("user_joined", (data) => {
        let new_div = document.createElement("div")
        new_div.className = "center"
        new_div.textContent = data.username + " has joined the chat"
        document.getElementById("chat_area").appendChild(new_div)
    })
    socket.on("user_left", (data) => {
        let new_div = document.createElement("div")
        new_div.className = "center"
        new_div.textContent = data.username + " has left the chat"
        document.getElementById("chat_area").appendChild(new_div)
    })


    document.getElementById("submit_btn").addEventListener("click", (e) => {
        e.preventDefault();
        let messageValue = document.getElementById("message").value;
        socket.emit("message_sent", { "message": messageValue })

        document.getElementById("message").value = "";
    });

    socket.on("left_message_sent", (data) => {
        let new_div = document.createElement("div")
        new_div.className = "left"
        new_div.textContent = data.message
        document.getElementById("chat_area").appendChild(new_div)
    })

    socket.on("right_message_sent", (data) => {
        let new_div = document.createElement("div")
        new_div.className = "right"
        new_div.textContent = data.message
        document.getElementById("chat_area").appendChild(new_div)
    })

    document.getElementById("send_pic").addEventListener("click",(e)=>{
        let file_input = document.getElementById("file_input")
        // If file exists then emit the event
        if(file_input.files.length != 0){
            let selected_files = file_input.files[0]
            socket.emit("send_file", selected_files,selected_files.type);
        }
    })

    socket.on("left_file_sent",(type,file_name)=>{
        let new_div = document.createElement("div")
        new_div.className = "left_file"
        //If the file is an image
        if(type.split("/")[0] == "image"){
            let new_img_tag = document.createElement("img")
            new_img_tag.className = "img_file"
            new_img_tag.src = file_name.split("HDD")[1]
            new_div.appendChild(new_img_tag)
        }
        //If the file is some other multimedia
        //Try using <audio> and <video> for audio and video files
        else{
            let new_anchor_tag = document.createElement("a")
            new_anchor_tag.className = "any_file"
            new_anchor_tag.target = "_blank"
            new_anchor_tag.textContent = type.split("/")[1]
            new_anchor_tag.href = file_name.split("HDD")[1]
            new_div.appendChild(new_anchor_tag)
        }
        //Add the newly made div to the chat area
        document.getElementById("chat_area").appendChild(new_div)
    })

    socket.on("right_file_sent",(type,file_name)=>{
        let new_div = document.createElement("div")
        new_div.className = "right_file"
        //If the file is an image
        if(type.split("/")[0] == "image"){
            let new_img_tag = document.createElement("img")
            new_img_tag.className = "img_file"
            new_img_tag.src = file_name.split("HDD")[1]
            new_div.appendChild(new_img_tag)
        }
        //If the file is some other multimedia
        else{
            let new_anchor_tag = document.createElement("a")
            new_anchor_tag.className = "any_file"
            new_anchor_tag.target = "_blank"
            new_anchor_tag.textContent = type.split("/")[1]
            new_anchor_tag.href = file_name.split("HDD")[1]
            new_div.appendChild(new_anchor_tag)
        }
        //Add the newly made div to the chat area
        document.getElementById("chat_area").appendChild(new_div)
    })


document.getElementById("start_record").addEventListener("click",(e)=>{
        audioRecorder.start_record()
            .then(() => { //on success
                console.log("Recording Audio...")    
            }) 
            .catch(error => { //on error
                //No Browser Support Error
                if (error.message.includes("mediaDevices API or getUserMedia method is not supported in this browser.")) {       
                    console.log("To record audio, use browsers like Chrome and Firefox.");
                }
            });
    })

document.getElementById("stop_record").addEventListener("click",(e)=>{
        audioRecorder.stop_record()
        .then((audioAsblob) => { //stopping makes promise resolves to the blob file of the recorded audio
        socket.emit("send_file",audioAsblob.audioBlob,audioAsblob.mimeType.split(";")[0])
            
        })
        .catch(error => {
            //Error handling structure
            switch (error.name) {
                case 'InvalidStateError': //error from the MediaRecorder.stop
                    console.log("An InvalidStateError has occured.");
                    break;
                default:
                    console.log("An error occured with the error name " + error.name);
            };
 
        });

    })

var audioRecorder = {
        
        //To store the audio in the array
        audioBlobs:[],

        //To store the reference of MediaRecorder object(MDN)
        mediaRecorder:null,

        //To store the reference of the stream of audio
        streamBeingCaptured:null,

    start_record:function(){
        
        // Check if there are media devices and can they be used
        if(navigator.mediaDevices && navigator.mediaDevices.getUserMedia){

            //Only ask for audio
            //If getUserMedia return a successful promise then the function returns successful and then statement is executed
            return navigator.mediaDevices.getUserMedia({audio:true})
            .then((stream)=>{

                //Stored stream reference
                audioRecorder.streamBeingCaptured = stream;

                //Created a MediaRecorder
                audioRecorder.mediaRecorder = new MediaRecorder(stream);

                //Emptied the previous audio data if any
                audioRecorder.audioBlobs = [];

                //If there is audio data coming then push the data into the array
                audioRecorder.mediaRecorder.addEventListener("dataavailable",(event)=>{
                    audioRecorder.audioBlobs.push(event.data)
                })

                //Start the recording
                audioRecorder.mediaRecorder.start();
            })
            .catch((err)=>{
                console.log("This is in err of audio")
                console.log(err)
                alert("Please allow the usage of microphone to record audio")
            })
        }
},      
        stop_record:function(){
        return new Promise(resolve => {
            //save audio type to pass to set the Blob type
            let mimeType = audioRecorder.mediaRecorder.mimeType;
 
            //listen to the stop event in order to create & return a single Blob object
            audioRecorder.mediaRecorder.addEventListener("stop", () => {
                //create a single blob object, as we might have gathered a few Blob objects that needs to be joined as one
                let audioBlob = new Blob(audioRecorder.audioBlobs, { type: mimeType });
 
                //resolve promise with the single audio blob representing the recorded audio
                resolve({audioBlob,mimeType});
            });
                //Stop the recording
                audioRecorder.mediaRecorder.stop();

                // Stop the ongoing audio Stream
                audioRecorder.stopStream();

                //Reset API properties for the next recording
                audioRecorder.resetRecordingProperties();
        })
        },
        stopStream:function(){
            //Take the reference of the active stream and get all tracks from it then stops each ongoing track
            audioRecorder.streamBeingCaptured.getTracks().forEach(track => {
                track.stop();
            });
        },
        resetRecordingProperties:function(){
        audioRecorder.mediaRecorder = null;
        audioRecorder.streamBeingCaptured = null;
 
        /*No need to remove event listeners attached to mediaRecorder as
        If a DOM element which is removed is reference-free (no references pointing to it), the element itself is picked
        up by the garbage collector as well as any event handlers/listeners associated with it.
        getEventListeners(audioRecorder.mediaRecorder) will return an empty array of events.*/
        }
}


    //Used when passing bytes from client to server during file sharing
    //Previously used method for sharing files

    // function arrayBufferToBase64(buffer) {
    //     let binary = '';
    //     const bytes = new Uint8Array(buffer);
    //     for (let i = 0; i < bytes.byteLength; i++) {
    //         binary += String.fromCharCode(bytes[i]);
    //     }
    //     return btoa(binary);
    // }


    //Simpler method to record audio
    //Did'nt implement just pasted here to learn

    //     document.addEventListener('DOMContentLoaded', () => {
    //     const startRecordButton = document.getElementById('startRecord');
    //     const stopRecordButton = document.getElementById('stopRecord');
    //     const audioPlayer = document.getElementById('audioPlayer');
        
    //     let mediaRecorder;
    //     let audioChunks = [];

    //     startRecordButton.addEventListener('click', startRecording);
    //     stopRecordButton.addEventListener('click', stopRecording);

    //     function startRecording() {
    //         navigator.mediaDevices.getUserMedia({ audio: true })
    //             .then((stream) => {
    //                 mediaRecorder = new MediaRecorder(stream);

    //                 mediaRecorder.ondataavailable = (event) => {
    //                     if (event.data.size > 0) {
    //                         audioChunks.push(event.data);
    //                     }
    //                 };

    //                 mediaRecorder.onstop = () => {
    //                     const audioBlob = new Blob(audioChunks, { type: 'audio/wav' });
    //                     audioPlayer.src = URL.createObjectURL(audioBlob);
    //                 };

    //                 mediaRecorder.start();
    //                 startRecordButton.disabled = true;
    //                 stopRecordButton.disabled = false;
    //             })
    //             .catch((error) => {
    //                 console.error('Error accessing microphone:', error);
    //             });
    //     }

    //     function stopRecording() {
    //         if (mediaRecorder && mediaRecorder.state !== 'inactive') {
    //             mediaRecorder.stop();
    //             startRecordButton.disabled = false;
    //             stopRecordButton.disabled = true;
    //         }
    //     }
    // });
   
</script>

</html>